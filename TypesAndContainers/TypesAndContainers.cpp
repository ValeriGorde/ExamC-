#include <iostream>
#include <vector>
#include <list>
#include <map>
#include <stack>
using namespace std;

int main()
{
    setlocale(LC_ALL, "ru");
    cout << "Неявное преобразование:" << endl;
    double a = 20.23;
    int b = a; //неявное преобразование
    cout << b << endl;

    char hc = 'a';
    void* pv = NULL;
    pv = reinterpret_cast<void*>(hc);

    cout << endl << "Явное преобразование: " << endl;
    double c = 14.11;
    cout << (int)c << endl;
    cout << (bool)c << endl; //выведет true, тк не = 0
    cout << (char)c << endl; //сначала преобразует значение в Int, а затем в символ ASCII кода

    cout << "Операторы явного преобразования: " << endl;
    char d{ 'a' };
    cout << d << " = " << static_cast<int>(d) << endl; //static_cast принимает в качестве входного параметра одно значение и преобразует это значение в тип указанный в угловых скобках

    const char* str = "bye"; // константная строка
    char* strNew = const_cast<char*>(str); //превратилась в неконстантную

    //также есть оператор dynamic_cast - используется для преобразования указателей и ссылок из базовых классов в производные классы 
    //reinterpret_cast - самый небезопасный, для приведения несовместимых типов (например указатель в инт)


    cout << "Контейнерные классы в С++:" << endl;
    //Вектор - тот же динамический массив, позволяет произвольно изменять значения элементов
    vector<int> abs = { 1, 2, 3 };
    abs.push_back(4); //добавили в конец элемент со значением 4
    abs.at(0) = 8; //изменили первый элемент вектора
    for (int i = 0; i < abs.size(); i++) {
        cout << abs[i] << "\t";
    }

    //Лист - двусвязный список, каждый элемент которого содержит 2 указателя - на следующий и предыдущий элемент
    list<int> songs{1, 2, 3, 4, 5};
    cout << "Первый элемент в списке = " << songs.front() << endl;
    cout << "Последний элемент в списке = " << songs.back() << endl;
    cout << "Все элементы списка: " << endl;
    for (int n : songs)
       cout << n << "\t";
    cout << endl;

    //Map - ассоциативный контейнер, который работает с парой "ключ-значение"
    map <string, int> mp; 

    cout << "Введите количество эле ментов: "; int n; cin >> n;

    for (int i = 0; i < n; i++) {
        cout << i << ") "; string a; cin >> a;
        mp[a] = i;  // добавляем новые элементы
    }

    map <string, int> ::iterator it = mp.begin(); //создаем итератор для того, чтобы оперировать с контейнером
    cout << "А вот все отсортированно: " << endl;
    for (int i = 0; it != mp.end(); it++, i++) {  // выводим их
        cout << i << ") Ключ " << it->first << ", значение " << it->second << endl;
    }


    //Стек - контейнер адаптивный, который работает по принципу FIFO
    stack<int> steck;  // создаем стек

    int i = 0;

    cout << "Введите шесть любых целых чисел: " << endl; // предлагаем пользователю ввести 6 чисел
    while (i != 6) {
        int a;
        cin >> a;

        steck.push(a);  // добавляем введенные числа
        i++;
    }

    if (steck.empty()) cout << "Стек не пуст";  // проверяем пуст ли стек (нет)

    cout << "Верхний элемент стека: " << steck.top() << endl; // выводим верхний элемент
    cout << "Давайте удалим верхний элемент " << endl;

    steck.pop();  // удаляем верхний элемент

    cout << "А это новый верхний элемент: " << steck.top(); // выводим уже новый



    return 0;
 }
